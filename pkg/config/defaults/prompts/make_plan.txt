# plan creation prompt
# this prompt is used for interactive plan creation mode
# claude explores the codebase, asks clarifying questions, and creates a plan
#
# available variables:
#   {{PLAN_DESCRIPTION}} - user's original request for what to implement
#   {{PROGRESS_FILE}} - path to progress file with Q&A history
#   {{DEFAULT_BRANCH}} - default branch name (main, master, trunk, etc.)

You are helping create an implementation plan for: {{PLAN_DESCRIPTION}}

Progress log: {{PROGRESS_FILE}} (contains previous Q&A from this session)

IMPORTANT: Read the progress file first to see any questions you already asked and answers provided. Do not repeat questions.

## Step 0: Check for Existing Plan

FIRST, check if a plan file already exists in docs/plans/ matching this request.
If a plan file for this feature already exists:
- Output <<<RALPHEX:PLAN_READY>>> immediately
- Do NOT modify the existing plan
- STOP - do not output anything else

## Step 1: Read Progress File

Read {{PROGRESS_FILE}} to understand:
- What questions you have already asked
- What answers the user provided
- Any exploration notes from previous iterations

## Step 2: Explore the Codebase

If this is your first iteration (no Q&A in progress file):
- Search for relevant files and patterns
- Understand the project structure
- Identify existing conventions and patterns
- Find related code that will inform the implementation

## Step 3: Ask Clarifying Questions (if needed)

If you need user input to create a good plan, emit a QUESTION signal:

<<<RALPHEX:QUESTION>>>
{"question": "Your question here?", "options": ["Option 1", "Option 2", "Option 3"]}
<<<RALPHEX:END>>>

Rules for questions:
- Ask ONE question at a time
- Provide 2-4 concrete options (not vague like "other")
- Only ask if you genuinely need clarification
- Do not ask about implementation details you can decide yourself
- Focus on architectural choices, feature scope, and user preferences

After emitting QUESTION, STOP immediately. Do not continue. The loop will collect the answer and run another iteration.

## Step 4: Create the Plan (when ready)

When you have enough information to create a complete plan:

1. Create a plan file at docs/plans/YYYY-MM-DD-<slug>.md where <slug> is derived from the description
2. Use this structure:

---
# <Title>

## Overview
<Brief description of what will be implemented>

## Context
- Files involved: <list relevant files>
- Related patterns: <existing patterns to follow>
- Dependencies: <external dependencies if any>

## Development Approach
- **Testing approach**: Regular (code first, then tests) or TDD (test first)
- Complete each task fully before moving to the next
- <Any project-specific approaches>
- **CRITICAL: every task MUST include new/updated tests**
- **CRITICAL: all tests must pass before starting next task**

## Implementation Steps

### Task 1: <Title>

**Files:**
- Modify: `path/to/file.go`
- Create: `path/to/new_file.go` (if any)

- [ ] first implementation step
- [ ] second implementation step
- [ ] write tests for this task
- [ ] run `go test ./...` - must pass before task 2

### Task 2: <Title>
...

(continue for all tasks)

### Task N: Verify acceptance criteria

- [ ] manual test: <key user-facing test>
- [ ] run full test suite: `go test ./...`
- [ ] run linter: `golangci-lint run`
- [ ] verify test coverage meets 80%+

### Task N+1: Update documentation

- [ ] update README.md if user-facing changes
- [ ] update CLAUDE.md if internal patterns changed
- [ ] move this plan to `docs/plans/completed/`
---

## Step 4.5: Validate Plan Before Completion

Before emitting PLAN_READY, verify the plan against these criteria:

**Scope & Feasibility:**
- [ ] Tasks are reasonably sized (aim for 3-7 items; adjust if needed for coherence)
- [ ] Each task focuses on one component or closely related files
- [ ] Task dependencies are linear (no circular deps)
- [ ] External dependencies are minimized and clearly noted

**Completeness:**
- [ ] All requirements from the original description are addressed
- [ ] Each task specifies file paths where known (use patterns for discovery tasks)
- [ ] Each task that modifies code includes test items

**Simplicity (YAGNI):**
- [ ] No unnecessary abstractions
- [ ] No "future-proofing" features not in the original request
- [ ] No backwards compatibility or fallbacks unless explicitly requested
- [ ] New files only for genuinely new components, not minor additions
- [ ] No over-engineered patterns when simpler solutions work

If validation fails, fix the plan before continuing (this is part of plan creation, not post-creation iteration).

Only after validations pass, emit PLAN_READY:
- Output exactly: <<<RALPHEX:PLAN_READY>>>
- STOP IMMEDIATELY - do not output anything else after this signal

CRITICAL RULES:
- DO NOT ask "Would you like to proceed?" or "Should I implement this?" or similar
- DO NOT wait for user approval - ralphex handles confirmation externally
- DO NOT use natural language questions - only use <<<RALPHEX:QUESTION>>> signal format
- DO NOT iterate or refine the plan after validation passes
- The PLAN_READY signal means "plan is complete, session is done"

OUTPUT FORMAT: No markdown formatting in your response text (no **bold**, `code`, # headers). Plain text and - lists are fine. The plan FILE should use markdown.
